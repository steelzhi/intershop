Артур, привет!

В задании указано, что нужно написать OpenApi интеграции основного сервиса и сервиса платежей. Но OpenApi
создается для @RestController, а у меня в основном приложении запрос к сервису платежей происходит в @Controller
(CartController и OrderController). Функционал запроса к сервису платежей можно было бы вынести в отдельно
созданный @RestController основного приложения, но мне кажется это не оптимальным - в таком случае бы пришлось на этапах 
формирования "Корзины" и совершения заказа сперва обращаться из контроллеров основного сервиса (которые просто 
@Controller) в этот @RestController, а затем из созданного @RestController делать запросы из основного сервиса в сервис 
платежей. Поэтому я оставил функционал обращения в сервис платежей внутри уже созданных @Controller основного 
приложения, OpenApi подготовил для сервиса платежей.

# intershop

Инструкция по работе с приложением.
1. Запуск программы.
Запуск можно осуществить как локально (в IDE), так и в Docker-контейнере:

        1.1. Локальный:
            1.1.1. Запустить Docker. В нем запустить Redis Server командой:
            docker run --name redis-server -it --rm -p 6379:6379 redis:7.4.2-bookworm sh -c "redis-server && sleep 7 && redis-cli"
            1.1.2. Запустить MainServiceApplication#main (запустится основной сервис на порте 8180).
            1.1.3. Запустить PaymentServiceApplication#main (запустится сервис платежей на порте 9090).
        1.2. В Docker-контейнере:
            1.2.1. Для локального запуска и для запуска в Docker-контейнере применяются разные настройки, поэтому необходимо провести перенастройку в модуле main-app:
                1.2.1.1. Файл application.yml, параметр spring.data.redis.host: закомментировать значение "127.0.0.1", раскомментировать значение "redis";
                1.2.1.2. Класс Constants, поле HOST: закомментировать значение "localhost", раскомментировать значение "payment-service";
                1.2.1.3. Тестовые классы (тесты выполняются на настройках локального запуска программы, поэтому часть тестов нужно закомментировать, чтобы можно было произвести сборку проекта) - закомментировать в классах:
                    1.2.1.3.1. ItemAllLayersTest: весь класс.
                    1.2.1.3.2. CartAllLayersTest: тест getCart() (он самый последний на странице).
                    1.2.1.3.3. RedisTemplateTest: весь класс.
            1.2.2. Собрать проект командой "gradle clean build".
            1.2.3. Запустить Docker. В терминале IDE выполнить команду "docker compose up".

2. Перейти в браузере по адресам: 

        2.1. http://localhost:8180/main/items (адрес интернет-магазина).
        2.2. http://localhost:9090/payments/balance (просмотр созданного текущего баланса; при совершении заказов баланс будет уменьшаться).

Приложение готово к работе.

Примечания:
- Внизу главной страницы есть кнопка для добавления новых товаров.
- Для удобства проверки задания реализована пагинация в формате "2 товара на странице".
- Сервис платежей запускается на порту 9090 (параллельно с ним нужно запускать основное приложение). Если при локальном запуске сервис платежей не запущен, в "Корзине" не будет отображаться кнопка "Купить" и будет выведено сообщение о недоступности сервиса.
- Баланс - случайная величина в диапазоне [0; 1_000_000). Если на балансе недостаточно средств, то при попытке сделать заказ будет осуществлен переход на страницу с информацией о том, сколько средств не хватает.


- Новое:
1. Если пользователь не вошел в личный кабинет, то:
1.1. Пользователю будут доступны только главная страница и страница товаров (соответственно, кнопки "Корзина" и "Заказы" пропадут).
1.2. На страницах из п. 1.1 в правом верхнем углу появится кнопка "Войти в личный кабинет".
2. Если пользователь вошел в личный кабинет, то на всех страницах в правом верхнем углу появляется кнопка "Выйти из личного кабинета".
- Запустить контейнер Keycloak. Перейти по адресу localhost:8080 -> Clients -> Create client -> ...
3. Для прохождения тестов нужно запустить Keycloak
4. В schema.sql создано несколько пользователей. Для проверки корректности работы программы проще всего использовать пользователя с логином "1" и паролем "1" и пользователя с логином "2" и паролем "2" (все данные вводятся без кавычек).